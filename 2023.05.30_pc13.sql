 SELECT MOD(10,3.7), REMAINDER(10,3.7) FROM DUAL;
 SELECT  FLOOR(1332.69), CEIL(1332.69)  FROM DUAL;
 
 SELECT WIDTH_BUCKET(88,0,100,10) FROM DUAL;
 SELECT WIDTH_BUCKET(10, 9000, 500, 5) FROM DUAL;
  
 SELECT MEM_NAME  회원이름, MEM_BIR 회원생일,  MEM_NAME ||  '님은 ' || TO_CHAR(MEM_BIR,'YYYY"년" MM"월 출생이고 태어난 요일은 " DAY') 
          FROM MEMBER;
 
 SELECT PROD_LGU, PROD_BUYER, COUNT(*), SUM(PROD_COST)
 FROM PROD
 GROUP BY CUBE(PROD_LGU, PROD_BUYER);
 
 SELECT * FROM PROD;
 
 SELECT PROD_LGU
     , PROD_BUYER
     , COUNT(*)
     , SUM(PROD_COST)
FROM   PROD
GROUP  BY PROD_LGU, ROLLUP(PROD_BUYER);

--회원 중에 성이 '김' 이고, 성 다음에  '성' 또는 '형' 이 있는 회원을 검색

SELECT MEM_ID 회원ID, MEM_NAME 회원명
FROM MEMBER
WHERE REGEXP_LIKE (MEM_NAME, '^김(성|형)');

-- 상품 이름 중에 '삼성' 이라는 말이 있고, 숫자 두 개가 같이 있는 상품의 
-- 상품코드, 상품명, 판매가를 검색하시오?

SELECT PROD_ID 상품ID, PROD_NAME 상품명
FROM PROD
WHERE REGEXP_LIKE (PROD_NAME, '^삼성.*\d\d');

SELECT REGEXP_SUBSTR('Java Flex Oracle', '[^ ]+')
FROM DUAL;

SELECT MEM_NAME 회원이름 , MEM_MAIL, REGEXP_SUBSTR(MEM_MAIL, '[^@]+') 이메일아이디, REGEXP_SUBSTR(MEM_MAIL, '[^@]+',1,2) 이메일서버
FROM MEMBER;
-------

SELECT REGEXP_INSTR('JAVA Flex Oralce', '[ae]') RESULT FROM DUAL; --결과 8 (a나 e가 첫번째 오는 위치 => 8)

SELECT REGEXP_INSTR('JAVA Flex Oracle','[ae]', 1, 1, 0, 'i') RESULT1,
       REGEXP_INSTR('JAVA Flex Oracle','[ae]', 3, 2, 1, 'i') RESULT2
       FROM DUAL; --여기서 I는 대소문자를 구별하지 않겠다는 의미
       
SELECT REGEXP_REPLACE ('JAVA Flex Oracle', '[^ ]+', 'C++')
FROM DUAL;

----------------
SELECT MEM_ID 회원ID, MEM_REGNO1||'-'||MEM_REGNO2 "주민등록번호", MEM_NAME 성명, TO_CHAR(MEM_BIR, 'YYYY-MM-DD') 생일
FROM MEMBER
ORDER BY MEM_REGNO1, MEM_REGNO2;

----------------
SELECT * FROM LPROD;
SELECT * FROM PROD;
SELECT * FROM LPROD, PROD;
SELECT COUNT(*) FROM LPROD, PROD, BUYER;

----
SELECT BUYER_ID 거래처코드, BUYER_NAME 거래처명, SUM(BUY_QTY * BUY_COST) 매입금액
FROM BUYPROD, PROD, BUYER
WHERE BUY_DATE BETWEEN '2020-01-01' AND '2020-01-31'
AND      BUY_PROD   = PROD_ID
AND      PROD_BUYER = BUYER_ID
GROUP BY BUYER_ID, BUYER_NAME 
ORDER BY BUYER_ID, BUYER_NAME;

SELECT * FROM PROD;
SELECT * FROM BUYER;
SELECT * FROM BUYPROD;

------------------------
CREATE TABLE A
(NO NUMBER(3) NOT NULL,
 NAME VARCHAR2(20) NOT NULL,
 CONSTRAINT PK_A PRIMARY KEY(NO));
 
CREATE TABLE B
(NO NUMBER(3) NOT NULL,
 SCORE NUMBER(3) NOT NULL,
 CONSTRAINT PK_B PRIMARY KEY(NO));
 
INSERT INTO A VALUES(1, '김철수');
INSERT INTO A VALUES(2, '박미미');
INSERT INTO A VALUES(3, '정다비');
INSERT INTO A VALUES(4, '멘토스');
INSERT INTO A VALUES(5, '박버거');

INSERT INTO B VALUES(1, 60);
INSERT INTO B VALUES(2, 71);
INSERT INTO B VALUES(5, 99);
INSERT INTO B VALUES(7, 100);


SELECT * FROM A;
SELECT * FROM B;
SELECT * FROM A,B;

--INNER JOIN
SELECT *
FROM A INNER JOIN B ON A.NO = B.NO;

SELECT * 
FROM A,B
WHERE A.NO = B.NO;

-- OUTER JOIN
-- 1) LEFT OUTER JOIN -- 왼쪽 테이블 기준으로 JOIN 하겠다. ( 일치되는 값이 없으면 NULL)
SELECT * FROM A LEFT OUTER JOIN B ON (A.NO = B.NO);
SELECT * FROM A,B WHERE A.NO = B.NO (+);-- 일반 조인에 (+) 붙이면 아우터 조인
                                        -- (+)안붙은 테이블이 기준이됨 
SELECT * FROM A,B WHERE A.NO  (+) = B.NO;

SELECT * FROM A RIGHT OUTER JOIN B ON (A.NO = B.NO);

--3) FULL OUTER JOIN
--왼쪽 테이블과 오른쪽 테이블의 합집합.
SELECT * FROM A FULL OUTER JOIN  B ON (A.NO = B.NO);

SELECT * FROM A,B WHERE A.NO = B.NO (+)
UNION
SELECT * FROM A,B WHERE A.NO(+)= B.NO ;

---------------------------------------------------------------
-- 전체상품의 2020년 1월 입고수량을 검색 조회 ( Alias는 상품코드, 상품명, 입고수량 )
---------------------------------------------------------------

--1. 일반 JOIN
SELECT P.PROD_ID 상품코드, P.PROD_NAME 상품명, SUM(B.BUY_QTY) 입고수량
FROM BUYPROD B, PROD P
WHERE B.BUY_DATE BETWEEN '2020-01-01' AND '2020-01-31'
AND B.BUY_PROD = P.PROD_ID
GROUP BY P.PROD_ID, P.PROD_NAME;

SELECT * FROM BUYPROD;
SELECT * FROM PROD;

--2. OUTER JOIN 
SELECT P.PROD_ID 상품코드, P.PROD_NAME 상품명, SUM(B.BUY_QTY) 입고수량
FROM PROD P LEFT OUTER JOIN BUYPROD B ON (B.BUY_PROD = P.PROD_ID)
WHERE B.BUY_DATE BETWEEN '2020-01-01' AND '2020-01-31'
AND B.BUY_PROD = P.PROD_ID
GROUP BY P.PROD_ID, P.PROD_NAME;

--3. ANSI JOIN
SELECT P.PROD_ID 상품코드, P.PROD_NAME 상품명, SUM(B.BUY_QTY) 입고수량
FROM PROD LEFT OUTER JOIN BUYPROD
ON(P.PROD_ID = B.BUY_PROD AND B.BUY_DATE BETWEEN '2020-01-01' AND '2020-01-31')
GROUP BY P.PROD_ID, P.PROD_NAME
ORDER BY P.PROD_ID, P.PROD_NAME;


    
